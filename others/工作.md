# docker
## 一、Image相关命令
- ==`docker images`：列出本地已下载的镜像==
- `docker rmi <image_id>`：删除**一个**本地镜像
- `docker rmi -f <image_id>`：强制删除镜像（即使有容器在使用它）
## 二、Container相关命令
- `docker ps`：**列出当前正在运行**的容器
- ==`docker ps -a`**列出所有容器**（包括已停止的容器）==
- `docker run [options] <image>`：**创建并启动**一个新容器
	``` bash
	docker run -it --name my_ubuntu18 \
	  -v /home/user/Documents:/shared-data \
	  ubuntu:18.04 \
	  bash
	```
- ==`docker start <container>`：启动一个已停止的容器==
	``` bash
	docker start -ai my_ubuntu18
	```
- `docker stop <container>`：**停止**一个运行中的容器（发送 SIGTERM）
- `docker rm <container>`：**删除一个已停止的容器**
- `docker rm -f <container>`：**强制删除一个容器**（包括运行中的）
## 三、系统与信息命令
- `docker version`：显示 Docker 的版本信息
# Linux驱动开发
## 一、核心工具链与依赖
``` bash
sudo apt update
# 安装编译器、构建工具、内核头文件
sudo apt install build-essential libncurses-dev flex bison libssl-dev libelf-dev
```
- **`build-essential`**: 包含 GNU `gcc`/`g++` 编译器、`make` 等核心开发工具。
- **`libncurses-dev`**: 用于 `make menuconfig` 等需要文本图形界面配置内核的工具。
- **`flex`, `bison`**: 语法分析器生成器，编译内核或某些驱动时可能需要。
- **`libssl-dev`, `libelf-dev`**: 提供加密和 ELF 文件支持，是现代内核编译所必需的。
## 二、将驱动编译成模块
1. 获得与你开发板上**正在运行的内核版本完全一致**的内核源码和配置文件
2. 在 PC 上创建一个目录，例如 `~/my_driver/`，然后创建两个文件：
	1. 驱动源码：`hello.c`
		``` C
		#include <linux/init.h>   // 包含模块的初始化和清理函数的宏
		#include <linux/module.h> // 包含内核模块相关的所有宏和函数
		#include <linux/kernel.h> // 包含 printk 等内核API
		
		// 模块加载时执行的函数
		static int __init hello_init(void)
		{
		    // printk 是内核的打印函数，KERN_INFO 是日志级别
		    // 这条信息会在驱动加载时打印到内核日志中
		    printk(KERN_INFO "Hello World! My first driver is loaded!\n");
		    return 0; // 返回 0 表示初始化成功
		}
		
		// 模块卸载时执行的函数
		static void __exit hello_exit(void)
		{
		    printk(KERN_INFO "Goodbye World! My first driver is unloaded.\n");
		}
		
		// 注册模块的入口和出口函数
		module_init(hello_init);
		module_exit(hello_exit);
		
		// 模块元信息（非必需，但强烈推荐）
		MODULE_LICENSE("GPL");              // 声明许可证（GPL是必须的，否则可能会污染内核）
		MODULE_AUTHOR("Your Name");         // 作者信息
		MODULE_DESCRIPTION("A simple hello world driver"); // 模块描述
		MODULE_VERSION("0.1");              // 模块版本
		```
	2. 编译脚本：`Makefile`
		``` bash
		# 指定目标架构，与你的开发板匹配
		ARCH ?= arm
		# ARCH ?= arm64
		
		# 指定交叉编译工具链前缀，与你的工具链匹配
		# 如果编译器是 arm-linux-gnueabihf-gcc，则前缀是 arm-linux-gnueabihf-
		CROSS_COMPILE ?= arm-linux-gnueabihf-
		# CROSS_COMPILE ?= aarch64-linux-gnu-
		
		# ！！！最重要的一步：指定你pc电脑上的开发板内核源码的绝对路径 ！！！
		KERNEL_DIR ?= /home/youruser/linux-kernel-myboard
		
		# 当前驱动源码目录
		obj-m += hello.o
		
		# 默认构建目标
		all:
		    # -C $(KERNEL_DIR) 命令 make 切换到内核源码目录
		    # M=$(PWD) 告诉内核构建系统，要构建的模块在当前目录
		    # modules 是内核构建系统的目标，意思是编译模块
		    $(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KERNEL_DIR) M=$(PWD) modules
		
		# 清理编译生成的文件
		clean:
		    $(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KERNEL_DIR) M=$(PWD) clean
		```
3. 在你的 PC 上，进入 `~/my_driver/` 目录，直接执行 `make`：
	``` bash
	cd ~/my_driver/
	make
	```
	- 如果在`makefile`中没有写`ARCH ?= arm`与`CROSS_COMPILE ?= arm-linux-gnueabihf-`，也可以在bash中添加
		``` bash
			export ARCH = arm
			export CROSS_COMPILE = arm-linux-gnueabihf-
		```
4. 如果一切配置正确，编译成功后你会看到生成了一系列文件，其中最重要的就是 **`hello.ko`**。  
	`.ko` (Kernel Object) 文件就是可加载的内核模块，也就是我们的驱动。
5. 在开发板上加载和测试驱动
	- 加载驱动
		使用 `insmod` (insert module) 命令加载驱动模块。**需要 root 权限**。
		``` bash
		# 在开发板的终端中执行：
		insmod hello.ko
		```
	- 卸载驱动
		使用 `rmmod` (remove module) 命令卸载驱动。
		``` bash
		rmmod hello
		```
## 三、将驱动编译进内核
1. 在 PC 上创建一个目录，例如 `~/my_driver/`，创建一个简单的驱动文件：
	``` C
	#include <linux/init.h>
	#include <linux/module.h>
	#include <linux/kernel.h>
	
	// 初始化函数
	static int __init mydriver_init(void)
	{
	    printk(KERN_INFO "MYDRIVER: Hello world, built-in to the kernel!\n");
	    return 0;
	}
	
	// 退出函数
	// 注意：编译进内核后，这个函数永远不会被调用，因为驱动无法卸载。
	// 但它可以保留，如果未来你想将其改为模块，代码就不用大改。
	static void __exit mydriver_exit(void)
	{
	    printk(KERN_INFO "MYDRIVER: Goodbye world.\n");
	}
	
	// 即使编译进内核，也通常保留这些宏，保持代码一致性
	module_init(mydriver_init);
	module_exit(mydriver_exit);
	
	MODULE_LICENSE("GPL");
	MODULE_AUTHOR("Your Name");
	MODULE_DESCRIPTION("A simple built-in driver");
	```
2. 将驱动代码放入内核树并配置 Kconfig，
	1. 选择存放位置，常见选择有：
		- `drivers/char/`： 用于字符设备驱动（最通用的选择）。
		- `drivers/misc/`： 用于不适合放在其他类的杂项驱动。
		- 创建一个新目录，如 `drivers/mydriver/`（适用于复杂的驱动）。
	2. 修改 Kconfig 文件
		Kconfig 文件定义了在内核配置界面（如 `menuconfig`）中可以看到的选项。你需要在你放置驱动的目录的 `Kconfig` 文件中添加一个配置选项。
		编辑 `drivers/char/Kconfig` 文件，在末尾或其他合适位置添加：
		``` kconfig
		# 在 drivers/char/Kconfig 中添加以下内容
		config MY_DRIVER
		    bool "My very first built-in driver"
		    default n
	    help
	      This is a simple hello world driver that is built into the kernel.
	      Say Y here if you want to enable it.
		```
		- `config MY_DRIVER`: 定义了一个名为 `MY_DRIVER` 的配置符号。
		- `bool`: 表示这是一个布尔选项（要么编译进内核 `Y`，要么不编译 `N`）。如果用 `tristate`，则表示可以编成模块 `M`。
		- `"My very first built-in driver"`: 这是在 `menuconfig` 中显示给用户的文本。
		- `default n`: 默认不启用。
		- `help`: 提供帮助信息。
	3. 修改 Makefile 文件
		Makefile 告诉编译系统如何编译你的源文件。编辑 `drivers/char/Makefile` 文件，添加一行：
		``` makefile
		# 在 drivers/char/Makefile 中添加一行
		obj-$(CONFIG_MY_DRIVER) += mydriver.o
		```
		- `$(CONFIG_MY_DRIVER)`: 这是一个变量，它的值取决于你在配置时的选择。
	    - 如果你在 `menuconfig` 中选择了 `Y`，那么这一行就变成 `obj-y += mydriver.o`，表示将 `mydriver.o` 编译进内核。
	    - 如果你选择了 `N`，则变成 `obj-n += mydriver.o`，表示不编译。
	    - 如果之前用的是 `tristate` 并且选择了 `M`，则会变成 `obj-m += mydriver.o`，表示编译成模块。
		- `mydriver.o`: 指定要编译的源文件是 `mydriver.c`。编译系统会自动寻找同名 `.c` 文件。
3. 配置内核并编译
	1. 启动内核配置界面
		``` bash
		make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig
		```
	2. 找到你的驱动选项
		在 `menuconfig` 的字符界面中，使用箭头键导航：
		1. 进入 `Device Drivers` 菜单。
		2. 再进入 `Character devices` 菜单。
		3. 你应该能看到刚刚添加的选项：`[*] My very first built-in driver`。
		4. 按 `Y` 键将其选中（前面会出现 `<*>`）。
	3. 保存并退出
	4. 编译整个内核
		``` bash
		# 使用 -j 选项利用多核CPU加速编译，数字根据你的CPU核心数定
		make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j4
		```
## 杂项设备驱动
- 三大设备：
	字符设备：IO的传入过程是以字符为单位，如I2C，SPI
		杂项设备：可以自动生成节点
	块设备：IO的传入过程是以块为单位，如TF卡
	网络设备：socket套接字
- 使用`cat`命令来访问
	``` bash
	cat /proc/misc
	```
- 杂项设备的主设备号相同，均为10，次设备号是不同的。主设备号在Linux系统中是唯一的，主设备号相同就可以视为同一设备
- 主设备号可以通过以下命令来查看
	``` bash
	cat /proc/devices
	```
- 杂项设备相关的结构体描述在`misdevice.h`中定义
	``` C
		struct miscdevice {
		int minor;
		const char *name;
		const struct file_operations *fops;
		struct list_head list;
		struct device *parent;
		struct device *this_device;
		const struct attribute_group **groups;
		const char *nodename;
		umode_t mode;
	};
	```
	`int minor`：次设备号
	`const char *name`：设备节点名
	`const struct file_operations *fops`：文件操作集
	- 文件操作集在`fs.h`中定义
	  ``` C
	  struct file_operations {
			struct module *owner;
			loff_t (*llseek) (struct file *, loff_t, int);
			ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
			ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
			ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
			ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
			int (*iopoll)(struct kiocb *kiocb, bool spin);
			int (*iterate) (struct file *, struct dir_context *);
			int (*iterate_shared) (struct file *, struct dir_context *);
			__poll_t (*poll) (struct file *, struct poll_table_struct *);
			long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
			long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
			int (*mmap) (struct file *, struct vm_area_struct *);
			unsigned long mmap_supported_flags;
			int (*open) (struct inode *, struct file *);
			int (*flush) (struct file *, fl_owner_t id);
			int (*release) (struct inode *, struct file *);
			int (*fsync) (struct file *, loff_t, loff_t, int datasync);
			int (*fasync) (int, struct file *, int);
			int (*lock) (struct file *, int, struct file_lock *);
			ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
			unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
			int (*check_flags)(int);
			int (*flock) (struct file *, int, struct file_lock *);
			ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
			ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
			int (*setlease)(struct file *, long, struct file_lock **, void **);
			long (*fallocate)(struct file *file, int mode, loff_t offset,
					  loff_t len);
			void (*show_fdinfo)(struct seq_file *m, struct file *f);
		#ifndef CONFIG_MMU
			unsigned (*mmap_capabilities)(struct file *);
		#endif
			ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,
					loff_t, size_t, unsigned int);
			loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,
						   struct file *file_out, loff_t pos_out,
						   loff_t len, unsigned int remap_flags);
			int (*fadvise)(struct file *, loff_t, loff_t, int);
		
			ANDROID_KABI_RESERVE(1);
			ANDROID_KABI_RESERVE(2);
			ANDROID_KABI_RESERVE(3);
			ANDROID_KABI_RESERVE(4);
		} __randomize_layout;
	  ```
	- 杂项设备的相关函数
		- ` int misc_register(struct miscdevice *misc)`：注册杂项设备
		- `void misc_deregister(struct miscdevice *misc)`：删除杂项设备
	- 注册杂项设备的流程
		1. 填充`miscdevice`结构体
		2. 填充`file_operations`的结构体成员，填充`struct module *owner`
		3. 注册杂项设备并生成设备节点
		``` C
		struct const file_operation xx_fops = {
			.owner = THIS_MODULE
			...............
		};
		struct miscdevice xx_dev = {
			.minor = MISC_DYNAMIC_MINOR//动态分配次设备号
			.name = "xxx"//设备节点名
			.fops = &xx_fops//该设备对应的文件操作集
		};
		static xxx_init(void) {
			int ret;
			
			ret = misc_register(&xx_dev);
			if(ret < 0) {
				printk("misc register is error\n");
				return 1;
			}
			else {
				printk("misc register is finish\n");
				return 0;
			}
		}
		static xxx_exit(void) {
			misc_deregister(&xx_dev);
			printk("misc deregister is finish\n");
		}
		```
# SDK
- Buildroot、Debian 和 Yocto 这三个工具的核心目的，都是为你手上的硬件（比如树莓派、一块定制电路板）制作一个可以开机运行的操作系统。
- Buildroot 是 Linux 平台上一个开源的嵌入式 Linux 系统自动构建框架。整个 Buildroot 是由 Makefile 脚本和 Kconfig 配置文件构成的。可通过Buildroot配置，编译出一个完整的可以直接烧写 到机器上运行的 Linux 系统软件。
- Buildroot 本身不具备扩展能力，用户需要自己通过脚本来完成工作。这些列出来的特点，都是和 Yocto 不同的地方。
- **工具链是一套用来编译和构建软件的程序集合**。在嵌入式开发中，我们指的是**交叉编译工具链（Cross Compilation Toolchain）**。
- Buildroot中的工具链
	在 `make menuconfig` 中，**Toolchain** 菜单是配置工具链的核心区域。它主要提供两种选择：
	- 内部工具链（Internal Toolchain）
	 - 外部工具链（External Toolchain）
- 全自动编译
	`./build.sh all` # 只编译模块代码（u-Boot，kernel，Rootfs，Recovery） # 需要再执行`./build.sh ./mkfirmware.sh` 进行固件打包 
	`./build.sh` # 编译模块代码（u-Boot，kernel，Rootfs，Recovery） # 打包成update.img完整升级包 # 所有编译信息复制和生成到out目录
- 模块编译
# 设备树
- **将硬件的描述（设备树文件）和内核代码分离开**
	- **内核**：只包含通用的代码和驱动，不包含具体的板级硬件信息。
	- **设备树**：专门描述具体板卡上的硬件细节，比如：
	    - 内存的大小和地址。
	    - CPU 的数量和型号。
	    - 时钟频率。
	    - 外部总线的信息（如 I2C, SPI, UART）。
	    - 连接在这些总线上的设备（如触摸屏、传感器、以太网芯片、Wi-Fi 模块）及其地址、中断引脚等。
- 名词解释
	- `DT`：设备树
	- `dts`：设备树源码
	- `dtsi`：通用设备树源码，使用`include`描述
	- `dtb`：编译设备树源码得到的文件
	- `dtc`：设备树编译器
- 编译设备树
	在编译内核时设备树编译器会编译成可执行文件
	编译设备树：`<dtc地址> -I dts -O dtb -o xxx.dtb xxx.dts`
	反编译设备树：`<dtc地址> -I dtb -O dts -o xxx.dts xxx.dtb`
## 设备树语法
1. 第一行要写的东西
	`/dts-v1/;`
2. 设备树根节点
	``` 
	/ {
	...
	}
	```
3. 子节点
	```
	[label]：node_name[设备地址] {
		
	}
	```
- 同一级的节点名字不能相同，不同级的节点名字可以相同
1. reg属性
	`reg = <address1 length1 address2 length2 ...>;`
	`#address-cells`与`#size-cells`确定了子节点中的`address`与`lengrh`的个数
	```
	node1 {
		#address-cells = <个数>;
		#size-cells = <个数>;
		node1-child {
			reg = <0x10>;
		}
	}
	```
2. model属性
	model属性的值是一个字符串，一般用来描述一些信息，比如设备的名字
	`model = "..."`
3. status属性
	model属性的值是一个字符串，有以下几种状态可选
	- `okay`：设备是可用状态
	- `disable`：设备是不可用状态
	- `fail`：设备是不可用状态并且设备检测到了错误
	- `fail-sss`：设备是不可用状态并且设备检测到了错误，sss是错误内容
4. compatible属性
	compatible是一个非常重要的属性，用来和驱动进行匹配，匹配成功后会执行驱动中的probe函数
	`compatible = "aaa", "bbb";`
	在匹配的时候会先使用第一个值`aaa`进行匹配，如果没有就会使用第二个值`bbb`进行匹配
``` C
/dts-v1/;

/*
这是芯片级的设备树文件，定义了 RK3506 SoC 内部的所有硬件模块，但它们的 status 通常默认为 disabled
*/
#include "rk3506.dtsi"

/*
这是板级的基础设备树文件，它基于芯片级文件，描述了评估板的通用硬件连接，并 enable 了需要的外设
*/
#include "rk3506-evb1-v10.dtsi"

/ {
	//明确了这是 BGA 封装 的 RK3506B 评估板。
	model = "Rockchip RK3506B(BGA) EVB1 V10 Board";
	compatible = "rockchip,rk3506b-evb1-v10", "rockchip,rk3506";
	/*
	这个节点定义了一个简单的、由 GPIO 控制的固定电压稳压器，它的主要目的是为LCD 屏幕提供 3.3V 的电源，并能够通过软件进行开关控制，从而实现节能（如在系统休眠时关闭屏幕电源）。
	*/
	vcc3v3_lcd_n: vcc3v3-lcd0-n {
		/*
		compatible:告诉内核使用哪个驱动程序来管理这个设备
		regulator-fixed:表示这是一个固定电压的稳压器
		*/
		compatible = "regulator-fixed";
		//使能信号是高电平有效
		enable-active-high;
		gpio = <&gpio0 RK_PA1 GPIO_ACTIVE_HIGH>;//通过一个 GPIO 引脚 (GPIO0_A1) 来打开/关闭屏幕供电
		regulator-name = "vcc3v3_lcd_n";
		//在系统启动阶段，内核应该开启这个稳压器
		regulator-boot-on;
		/*
		这个子节点用于配置稳压器在系统休眠（挂起到内存）状态下的行为。
		*/
		regulator-state-mem {
		//这个属性指定当系统进入休眠状态时，驱动程序应该自动关闭这个稳压器
			regulator-off-in-suspend;
		};
	};
	/*
	这个节点定义了一个由 GPIO 控制的固定 5V 稳压器，专门为 USB0 端口的 VBUS 供电。USB OTG (On-The-Go) 功能需要控制器能够主动提供 5V 电源，这个节点就是实现该功能的关键。
	*/
	vcc5v0_otg0: vcc5v0-otg0-regulator {
		compatible = "regulator-fixed";
		regulator-name = "vcc5v0_otg0";
		//电压范围,单位是微伏 (µV)
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		enable-active-high;
		gpio = <&gpio1 RK_PC4 GPIO_ACTIVE_HIGH>;// 控制引脚(GPIO1_C4)
		pinctrl-names = "default";
		/*
		`pinctrl-0`：对应 `pinctrl-names` 中的第一个状态（即 `"default"` 状态）所要使用的引脚配置。
		*/
		pinctrl-0 = <&vcc5v
		0_otg0_en>;// 引脚复用配置
	};
	vcc5v0_otg1: vcc5v0-otg1-regulator {
		compatible = "regulator-fixed";
		regulator-name = "vcc5v0_otg1";
		regulator-boot-on;
		regulator-always-on;
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		enable-active-high;
		gpio = <&gpio1 RK_PD0 GPIO_ACTIVE_HIGH>;// 控制引脚(GPIO1_D0)
		pinctrl-names = "default";
		pinctrl-0 = <&vcc5v0_otg1_en>;// 引脚复用配置
	};
};

/*
CMA 是一块预留的、物理连续的内存区域，专供大容量 DMA 传输的设备使用（例如**摄像头、视频编解码器、GPU**等），这对性能至关重要。
*/
&cma {
	size = <0x1600000>;
};

/*
启用显示与触摸系统
*/
&dsi {
	status = "okay";// 启用 MIPI-DSI 控制器，它负责将像素数据打包成符合 MIPI-DSI 协议的数据包
};
&dsi_dphy {
status = "okay";// 启用 D-PHY（物理层），它负责将 DSI 控制器产生的数字信号转换成高速串行差分信号，通过物理线缆传输出去
};
&dsi_in_vop {
	status = "okay";// 建立了 VOP (Video Output Processor) 和 DSI 控制器 之间的内部链接
};
&route_dsi {
	status = "okay";// 启用显示路由，使能了通往 DSI 接口的显示路由
};
&dsi_panel {
	power-supply = <&vcc3v3_lcd_n>;// 将屏幕的电源指向新定义的 regulator
};

&gt1x {
	power-supply = <&vcc3v3_lcd_n>;
	status = "okay";
};

/*
启用音频编解码器
*/
&es8388 {
	status = "okay";
};
&es8388_sound {
	status = "okay";
};
&sai1 {
	status = "okay";
};

/*
引脚控制 (Pinctrl) 配置
*/
&pinctrl {
	usb {
		vcc5v0_otg0_en: vcc5v0-otg0-en {
			/*
			GPIO1_C4
			RK_FUNC_GPIO:指定引脚的复用功能。这里设置为 GPIO 功能,这个引脚不会被分配给其他特定的硬件控制器
			&pcfg_pull_none:既不上拉也不下拉
			*/
			rockchip,pins = <1 RK_PC4 RK_FUNC_GPIO &pcfg_pull_none>;
		};
		vcc5v0_otg1_en: vcc5v0-otg1-en {
			rockchip,pins = <1 RK_PD0 RK_FUNC_GPIO &pcfg_pull_none>;
		};
	};
};

/*
配置 USB PHY 电源
*/
&u2phy_otg0 {
	vbus-supply = <&vcc5v0_otg0>;
	status = "okay";
};
&u2phy_otg1 {
	phy-supply = <&vcc5v0_otg1>;
	status = "okay";
};
```
# 鲁班猫（RK3576）
- 用户名：cat
- 用户密码：temppwd
- x11vnc密码：1
``` makefile

```
- 整体目的
	这个 Makefile 的目的是指导 `make` 工具如何将你的源代码文件（例如 `hellomodule.c`）编译成 Linux 内核模块文件（`hellomodule.ko`）。关键点在于：**编译内核模块必须使用与其运行目标内核版本完全匹配的源代码和配置**。你不能用系统自带的 `gcc` 直接编译，必须借助内核的构建系统（Kbuild）。