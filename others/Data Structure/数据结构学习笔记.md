# 第一章：引入
1. **数组**
	使用取地址符号&获取数组的地址时，返回的是数组第0个元素的内存地址
	- 如何打印数组中的所有元素
		``` C
		int a = {1, 2, 3};
		
		int *p = a;
		for(int i = 0; i < sizeof(a)/sizeof(a[0]); i++) {
			printf(“%d\n”, *(p+i));
		}
	```
2. **指针**
	和普通的变量一样，有自己的地址和内容。其内容是所指向的内存空间的地址
3. **通配符%p**
	``` C
	int a = 1;
	int *p = &a;
	printf(“a的地址为：%p，a的值为：%d”, &a, a);
	printf(“p的地址为：%p，p的值为：%p”, &p, p);
	```
4. **给字符串赋值**
	使用`strcpy`函数
	``` C
	char a[50] = {0};
	strcpy(a, “hello”);
	```
# 第二章：指针，结构体，动态内存分配
## 一、指针
- 设计一个函数，用于交换传入的两个变量的值
	``` C
	//调用前：
	//x(地址0x1000): 5
	//y(地址0x1004): 10
	
	//调用swap_by_address(&x, &y)时：
	//创建指针a(地址0x2000): 0x1000  ← 存储x的地址
	//创建指针b(地址0x2004): 0x1004  ← 存储y的地址
	
	//函数内操作：
	//*a = *b → 将地址0x1004的值(10)写入地址0x1000
	//*b = temp → 将临时值(5)写入地址0x1004
	
	//结果：
	//x(0x1000): 10
	//y(0x1004): 5
	
	void swap(int *m, int *n) {
		int temp = *m;
		*m = *n;
		*n = temp;
	}
	```
- 指针与数组关系十分密切，数组下标能完成的操作都可以通过指针完成
- 指针的算术运算
	给指针加上一个整数，实际上加的是这个整数和指针数据类型对应字节数的乘积
- ==指针=地址==
## 二、结构体
- 结构体指针
	``` C
	typedef struct {
		int x;
		int y;
	}coordinate;
	
	coordinate p;
	coordinate *pp = &p;
	
	//使用变量对成员进行访问
	p.x = 1;
	p.y = 2;
	
	//使用指针对成员进行访问
	(*pp).x = 1;
	(*pp).y = 2;
	//更通用的是
	pp->x = 1;
	pp->y = 2;
	```
## 三、内存分配
1. **内存分类**
	1. **全局内存（静态内存）**
		**静态声明的变量**和**全局变量**使用这部分内存，这些变量在程序开始运行时分配，直到程序终止才消失
	2. **栈内存**
		函数内部声明的变量使用这部分内存，在函数被调用时才创建，==不受用户控制==
	3. **堆内存（动态内存）**
		根据需求编写代码动态分配内存，可以编写代码释放，内存中的内容直到释放才消失，==受用户控制==
2. **动态内存分配**
	- **基本步骤**
		1. `void* malloc (size_t)`
			- `void*`：通用数据类型指针，**使用强制类型转换**
			- 返回值
				- 成功返回内存指针
				- 失败返回空指针
		2. 使用内存
		3. `free`
	- 例
		``` C
		int main(int agrc, char const *argv[]) {
			int *p = (int *)malloc(sizeof(int));
			*p = 15;
			printf(“%d”, *p);
			free(p);
			return 0;
			//p指针在栈内存中，指向了堆内存中的一个地址
		}
		```
# 第三章：顺序表与链表
## 一、顺序表
1. **定义**
	用一组连续的内存单元依次存储线性表的各个元素，也就是说，逻辑上相邻的元素，**实际的物理空间也是连续的**
2. **储存结构**
	``` C
	#define  MAXSIZE = 100
	typedef int Elemtypen;
	
	typedef struct {
		Elemtype data[MAXSIZE];
		int length;//表示当前线性表中有多少元素
	}SeqList;
	```
3. **初始化**
	``` C
	void initList(SeqList *L) {
		L->length = 0;
	}
	
	SeqList list;
	initList(&list);
	```
4. **在尾部添加元素**
	``` C
	int appendElem(SeqList *L, ElemType e) {
		if(L->length>=MAXSIZE) {
			printf(“full”);
			return 0;
		}
		L->data[L->length] = e;
		L->length++;
		return 1;
	}
	```
5. **遍历**
	``` C
	void listElem(SeqList *L) {
		for(int i = 0; i < L->length; i++) {
			printf(“%d ”, L->data[i]);
		}
		printf(“\n”);
	}
	```
6. **插入元素**
	``` C
	//pos从1开始
	int insertElem(SeqList *L, int pos, ElemType e) {
		if(pos < L->length) {
			for(int i = L->length-1; i >= pos-1; i—-) {
				L->data[i+1] = L->data[i];
			}
			L->data[pos-1] = e;
			L->length++;
		}
		return 1;
	}
	```
7. **删除元素**
	``` C
	int deleteElem(SeqList *L, int pos, ElemType *e) {
		*e = L->data[pos-1];
		if(pos < L->length) {
			for(int i = pos; i < L->length; i++) {
				L->data[i-1] = L->data[i];
			}
		}
		L->length—-;
		return 1;
	}
	```
8. **查找**
	``` C
	int findElem(SeqList *L, ElemType e) {
		for(int i = 0; i < L->length; i++) {
			if(L->data[i] == e) {
				return i + 1;
			}
		}
		return 0;
	}
	```
9. **动态内存初始化**
	``` C
	#define  MAXSIZE = 100
	typedef int Elemtypen;
	
	typedef struct {
		Elemtype *data;
		int length;//表示当前线性表中有多少元素
	}SeqList;
	
	void initList(void) {
		SeqList *L = (SeqList *)malloc(sizeof(SeqList));
		L->data = (ElemType *)malloc(sizeof(ElemType) * MAXSIZE);
		L->length = 0;
		return L;
		
		SeqList *List = initList();
	}
	```
	- 注
		- 使用一开始的定义形式在使用如山函数时要用取地址
		- 使用动态内存初始化不用取地址
## 二、链表
1. **定义**
	``` C
	typedef int ElemType;
	
	typedef struct node {
		ElemType data;
		struct node *next;
	}Node;
	```
2. **初始化**
	``` C
	Node* initList() {
		Node *head = (Node*)malloc(sizeof(Node));
		head->data = 0;
		head->next = NULL;
		return head;
	}
	
	Node *list = initList();
   ```
3. **头插法**
	``` C
	int insertHead(Node* L, ElemType e) {
		Node *p = (Node*)malloc(sizeof(Node));
		p->data = e;
		p->next = L->next;
		L->next = p;
	}
	```
4. **遍历**
	``` C
	void listNode(Node* L) {
		Node *p = L->next;
		while(p != NULL) {
			printf(“%d\n”, p->data);
			p = p->next;
		}
	}
	```
5. **尾插法**
	``` C
	
	```